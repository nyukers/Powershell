-----------------------------------------------------------------------------------------------------------------
Искусство создания сценариев на PowerShell. Часть 1
Иван Коробко

Листинг 1. Одиночный комментарий

[string]$a  # объявление строковой переменной



Листинг 2. Пример заголовка сценария

<#########################################################
Описание: Подключение сетевых дисков на основе данных, 
хранящихся в каталоге Active Direсtory
Автор: И.Коробко
Дата создания: 08.09.2009г.
Дата изменения: 03.05.2012г.
Язык: PowerShell, C# (API-функции)
Версия: 1.0 API реализовано на VB.NET
        2.0 API реализовано на C#
        2.1 Упрощен синтаксис в связи с обновлением оболочки PowerShell
Комментарий: имя конфигурационного файла совпадает 
с названием сценария
#########################################################>

Clear-Host
…



Листинг 3а. Список всех переменных среды

(get-item env:) | Out-GridView



Листинг 3б. Определение значения заданного параметра

(get-item env:).ПАРАМЕТР | Out-GridView



(get-item env:).USERNAME



Листинг 4. Определение значения заданного параметра

$ScriptName=$null
$ScriptPath=$null
if ($Host.Name -like "ConsoleHost")
{
$ScriptName=$MyInvocation.MyCommand.Name
$ScriptPath=$MyInvocation.InvocationName
Write-Host ("Имя сценария: {0}" -f $ScriptName)
Write-Host ("Путь к сценарию: {0}" -f $ScriptPath)
}
else
{
Write-Host "Ошибка: Некорректное имя хоста."
}




Листинг 5. Пример функции с именованными параметрами

function Enum-Sum
{
    Param (
        [double]$X,
        [double]$Y
    )
    $sum = $X+$Y
    return $sum
}

$SumXY = Enum-Sum -X 10.2 -Y 4.8
Write-Host ("Х + Y = {0}" -f $SumXY)



Листинг 6. Пример функции, обрабатывающей произвольное количество параметров

function Enum-Sum
{
    $element=0
    foreach($element in $args)
    {$sum+=$element}
    return $sum
}

$SumXY = Enum-Sum 10.2 4.8 5
Write-Host ("Summ = {0}" -f $SumXY)

-----------------------------------------------------------------------------------------------------------------

Искусство создания сценариев на PowerShell. Часть 2
Иван Коробко

Листинг 1. Чтение данных из XML-файла

$ScriptName=$null
$XMLName=$null

if ($Host.Name -like "ConsoleHost")
{
[string]$ScriptName=$MyInvocation.InvocationName
[string]$XMLName=$ScriptName -replace "ps1", "xml"
Write-Host $XMLName
[xml]$objXML=Get-Content .\$ScriptName #Чтение XML-файла
Write-host $obj.root.enable
...
}

else
{
Write-Host "Ошибка: Некорректное имя хоста."
}



Листинг 2. Пример функции автоматической замены значений

Function Freplace{

#Имя пользователя в сети
$ReplaceUserLogin = (Get-Item env:USERNAME).value
#Имя текущего домена
$ReplaceUserDomain = (Get-Item env:USERDOMAIN).value

#Определение списка групп, членом которых является 
#пользователь. Фильтрация по префиксу (LABEL)
$root=[ADSI]'LDAP://RootDSE'
$objUser = New-Object DirectoryServices.Directorysearcher("LDAP://{0}" -f $root.defaultNamingContext)
$objUser.filter=("(&(samaccountname={0}) ?
	(objectclass=person))" -f $ReplaceUserLogin)
$result=$objUser.findone()
$ReplaceUserFIO=[string]$result.properties.description
$dnpath=([string]$result.properties.distinguishedname).split(",")
$ReplaceUserdepartment = $dnpath[2] -replace("OU=", "")

foreach ($a in $args) {

$args
$temp= New-Object System.Text.StringBuilder
$ArFrom = '$fio', '$domain', '$department', '$login'
$ArTo = $ReplaceUserFIO,$ReplaceUserDomain, $ReplaceUserdepartment,$ReplaceUserLogin
for ($i=0; $i -lt ($ArFrom.length); $i++)
 {
   try{
       if ($a -like ("*"+$ArFrom[$i]+"*"))
       {
    $temp=$a.toupper()
    $a=$temp.Replace($ArFrom[$i].toupper(),$ArTo[$i])
        }
   }
   catch{}
}}

return $a.tolower() #Возвращаемое значение
}

[xml]$objXML=Get-Content .\$ScriptName #Чтение XML-файла
…

Freplace  | objXML.root.Department



Листинг 3. Пример формирования простейшего PSObejct

$b=@()
$c = 1,2,3
foreach ($e in $c)
{
$g = New-Object PSObject
Add-Member -InputObject $g -value $e -name ([string]"столбец-1") -MemberType "noteproperty"

Add-Member -InputObject $g -value ($e+1) -name ([string]"столбец-2") -MemberType "noteproperty"
$b+=$g
}
$b  | Out-GridView



Листинг 4а. Чтение и обработка данных учетной записи пользователя

#Обращение к учетной записи пользователя по GUID
$uGUID="71 F1 8A 66 58 89 C4 4F AD 46 CE 5D 4F 30 2C 69".replace(" ","")
$user = [ADSI]("LDAP://<GUID={0}>" -f $uGUID)

#Чтение данных учетной записи в переменные
$name = "{0} {1}" -f [string]$user.sn, [string]$user.givenName
$login = $user.sAMAccountName
$department = $user.department
$title = $user.title
$mail = $user.mail
$tlf = $user.telephoneNumber
$room = $user.physicalDeliveryOfficeName



Листинг 4б. Формирование списка пользователей и PSObject

#Поиск учетных записей пользователей в контейнере
$oGUID="C9 DB E6 E7 6C C3 1B 46 A8 0E 27 F2 B7 2A 57 23".replace(" ","")

$ou = [ADSISEARCHER]''
$ou.SearchRoot = [ADSI]("LDAP://<GUID={0}>" -f $oGUID)
$ou.Filter = "(&(objectclass=person)(!(objectclass=computer)))"
$results = $ou.FindAll() # Результаты поиска

$obj=@()

#Чтение данных из массива
foreach ($result in $results)
{
#Чтение данных учетной записи в переменные
$user = $result.GetDirectoryEntry()
$name = "{0} {1}" -f [string]$user.sn, [string]$user.givenName

$login = $user.sAMAccountName
$department = $user.department
$title = $user.title
$mail = $user.mail
$tlf = $user.telephoneNumber
$room = $user.physicalDeliveryOfficeName

#Создание PSObject
$ps = New-Object PSObject

#Запись данных в объект
Add-Member -InputObject $ps -MemberType NoteProperty -Name "Имя" -Value ([string]$name)
Add-Member -InputObject $ps -MemberType NoteProperty -Name "Имя в сети" -Value ([string]$login)
Add-Member -InputObject $ps -MemberType NoteProperty -Name "Должность" -Value ([string]$title)
Add-Member -InputObject $ps -MemberType NoteProperty -Name "Подразделение" -Value ([string]$department)
Add-Member -InputObject $ps -MemberType NoteProperty -Name "Почта" -Value ([string]$mail)
Add-Member -InputObject $ps -MemberType NoteProperty -Name "Телефон" -Value ([string]$tlf)
Add-Member -InputObject $ps -MemberType NoteProperty -Name "Комната" -Value ([string]$room)

$obj+=$ps
}


Листинг 4в. Вывод данных в выбранный источник

#Форматирование данных
$tmp = $obj | Sort-Object -Property "имя" #| Format-Table -Property "Имя", "Должность", "Подразделение"

#Вывод данных
Clear-Host
Write-Host ("Выберите способ вывода:{0}0 - консоль; {0}1 - GUI;{0}2 - файл (c:\report.txt); {0}3 - принтер (по умолчанию)." -f "`n")

switch (Read-Host)
{
0 {$tmp | Format-Table }
1 {$tmp | Out-GridView -Title "Информация"}
2 {$filename = "c:\report.txt"; $tmp | Out-File -FilePath $fileName;

Write-Host ('Данные выведены в файл "{0}"' -f $fileName) }
3 {$tmp | Out-Printer}
default {Write-Host "Невозможно вывести информацию."}
}



Листинг 5. Вывод ошибок в текстовый файл

#Очистка содержимого сценария
$error.clear
<#текст сценария
…
#>

  if($error -ne $null){
   $error | out-file $fileName  -Force -ErrorVariable +bugs -ErrorAction silentlycontinue
   }



Листинг 6. Вывод ошибок в журнал событий

#Очистка содержимого сценария
$error.clear
<#текст сценария
…
#>

#Проверка на существование ошибок
if($error -ne $null)
{
   #Проверка на существование источника в журнале событий
   $source="Power Shell Script"
   if ([System.Diagnostics.EventLog]::SourceExists($source) -eq $false)

    {[System.Diagnostics.EventLog]::CreateEventSource($source, "Application")}

   #Анализ полученных ошибок
   foreach ($r in $error)
   {
   #Формирование текста ошибок
   $errMsg = '{1}{0}Ошибка в строке {4}(Строка {2}, символ {3})' -f
    "`n",
    [string]$R.Exception.Message,
    [string]$R.InvocationInfo.ScriptLineNumber,
    [string]$R.InvocationInfo.OffsetInLine,
    [string]$R.InvocationInfo.Line

    #Контроль текста ошибки
    #$errMsg

    #Запись в журнал событий
    Write-EventLog –LogName Application –Source $source –EntryType Information –EventID 1 –Message $errMsg
    }
}

-------------------------------------------------------------------------------

Оценка эффективности использования серверного дискового пространства
Иван Коробко

Листинг 1. Формирование списка файлов, находящихся в указанной папке и ее подпапках

$rootPath = "…" # Путь к корневому каталогу

Get-ChildItem -Path $rootPath -Recurse | ? {$_.PSIsContainer -eq $false} | % { # Рекурсивный обход корневой папки
$size = $_.Length # Определение размера файла в байтах
$fname = $_.Name # Определение имени файла с его расширением
$fullname = $_.FullName # Получение полного пути к файлу, включая его имя
}



Листинг 2. Определение даты последнего изменения файла

...
# Получение полного пути к файлу, включая его имя
$fullname = $_.FullName
$oFile = (Get-Item $Fullname )
$oFile.LastWriteTime



Листинг 3. Сравнение даты последнего изменения файла с заданным пороговым значением

[datetime]$date1="02/03/2010" # Пороговое значение
…
… | % { …
[datetime]$date2 = $oFile.LastWriteTime
if ($date1 -gt $date2)
{Write-Host "Файл используется редко"}
else
{Write-Host "Файл используется часто"}
… }



Листинг 4. Шаблон для формирования объекта – таблицы

$obj=@() # Создание хеш-таблицы
… | % {
# Создание экземпляра PS-объекта
$psObject=New-Object PSObject
Add-Member -InputObject $psObject -MemberType "NoteProperty" -Name "---" -Value "---"| Out-Null
Add-Member -InputObject $psObject -MemberType "NoteProperty" …
$obj+=$psObject
}



Листинг 5. Формирование таблицы данных

$obj=@() # Создание виртуальной таблицы
… | % {
…

if ($date1 -gt $date2)
{

$obj = New-Object PSObject
Add-Member -InputObject $obj -MemberType "NoteProperty" -Name "FileName" -Value ([string]$fname)
Add-Member -InputObject $obj -MemberType "NoteProperty" -Name "FilePath" -Value ([string]$fullname)
Add-Member -InputObject $obj -MemberType "NoteProperty" -Name "LastWriteTime" -Value ([string]$date2)
Add-Member -InputObject $obj -MemberType "NoteProperty" -Name "FileSize" -Value ([string][math]::round([double]($size/[math]::pow(2,10)),2))
$tmpObj+=$obj
}
}

$tmpObj | Out-GridView # Экспорт в GUI
$tmpObj | Export-Csv -Path c:\report.txt # Экспорт в файл с разделителями



Листинг 6. Определение контрольной суммы файла

function Get-Checksum # Определение контрольной суммы файла
{
    Param (
        [string]$File=$(throw("Не указано имя файла")),
        [ValidateSet("sha1","md5")]
        [string]$Algorithm="md5"
    )
    $fs = new-object System.IO.FileStream $File, "Open"
    $algo = [type]"System.Security.Cryptography.$Algorithm"
    $crypto = $algo::Create()
    $hash = [BitConverter]::ToString($crypto.ComputeHash($fs)).Replace("-", "")
    $fs.Close()
    $hash
}
$ckeckSumm = Get-Checksum -Path $fileName -Algorithm md5




Листинг 7. Создание виртуальной таблицы на основе списка найденных файлов

# Объявление пустой виртуальной таблицы
$TmpTable1=@()
$rootPath = "…" # Путь к корневому каталогу
# Рекурсивный обход папки
Get-ChildItem -Path $rootPath -Recurse | ? {$_.PSIsContainer -eq $false} | % {

# Создание виртуального объекта
$ps=New-Object PSObject

# Определение характеристик файла
$size = $_.Length # Размер файла в байтах
$fname = $_.Name # Имя файла с его расширением
$fullname = $_.FullName # Полный путь к файлу, включая его имя

$ckeckSumm = Get-Checksum -Path $fullname -Algorithm md5

# Формирование новой строки таблицы
Add-Member -InputObject $ps -MemberType NoteProperty -Name "fname" -Value ([string]($fname)) | Out-Null
Add-Member -InputObject $ps -MemberType NoteProperty -Name "MD5" -Value ([string]($ckeckSumm)) | Out-Null
Add-Member -InputObject $ps -MemberType NoteProperty -Name "Size" -Value ([int64]($size)) | Out-Null

# Добавление новой строки виртуальной таблицы и заполнение 
# ее данными
$TmpTable1+=$ps
}

#Вывод данных на экран
$TmpTable1| Out-GridView



Листинг 8. Сортировка таблицы с данными по указанному столбцу

# Объявление пустой виртуальной таблицы
$TmpTable2=@()
#Сортировка данных
$TmpTable1 |Sort-Object -Property "MD5" | %{
# Создание виртуального объекта
$psSort=New-Object PSObject
# Формирование новой строки таблицы
Add-Member -InputObject $psSort -MemberType NoteProperty -Name "fname" -Value ([string]($_.fname)) | Out-Null
Add-Member -InputObject $psSort -MemberType NoteProperty -Name "MD5" -Value ([string]($_.md5)) | Out-Null
Add-Member -InputObject $psSort -MemberType NoteProperty -Name "Size" -Value ([int64]($_.size)) | Out-Null

# Добавление новой строки виртуальной таблицы и заполнение ее данными
$TmpTable2+=$psSort
}
#Вывод данных на экран
$TmpTable2| Out-GridView



Листинг 9. Формирование таблицы дублей

# Объявление переменных
$fullsize=0;  # Количество строк в таблице
[int64]$dublicate = 0 # Дисковое пространство, занимаемое файлом
$counter=0  # Количество дублей

# Объявление пустой виртуальной таблицы
$TmpTable3=@()
for ($c=0; $c -lt ($TmpTable2.Length);$c++)
{

# Сравнение ячеек с контрольной суммой с граничащими строками
# Сравнение двух соседних элементов
$compareTo = ($TmpTable2[$c].md5).compareto($TmpTable2[$c+1].md5)
# Сравнение двух соседних элементов
$compareFrom = ($TmpTable2[$c].md5).compareto($TmpTable2[$c-1].md5)

if ($compareTo -eq 0)
	{
	# Найден дубль. Количество дублей увеличивается на 1
	$counter+=1
	}
else
	{
# Найдены все дубли. Наобходимо записать данные в таблицу
if ($counter -ne 0)
{
# Создание виртуального объекта
$psDublicate=New-Object PSObject

# Создание новой строки
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "fname" -Value ([string]($TmpTable2[$c].fname)) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "MD5" -Value ([string]($TmpTable2[$c].md5)) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Size" -Value ([double]([math]::round($TmpTable2[$c].size/[math]::pow(2,20),3)))  | Out-Null #([int64]($TmpTable2[$c].size))
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Count" -Value ([int64]($counter)) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "TotalSize" -Value ([string]("={0}*{1}" -f (([double]([math]::round($TmpTable2[$c].size/[math]::pow(2,20),3)))), ([string]$counter))) | Out-Null
$fullsize+=1;
$duplicateSizer+=$TmpTable2[$c].size*$counter

# Запись новой строки в таблицу
$TmpTable3+=$psDublicate
}
$counter=0 # Обнуление счетчика
	}
}
$TmpTable3 | Out-GridView



Листинг 10. Создание заголовка в таблице

# Объявление пустой виртуальной таблицы
$TmpTable4=@()

# Создание 1-й строки
$psDublicate=New-Object PSObject
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "fname" -Value ([string]"Объем занятого дискового пространства (Мб):") | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "MD5" -Value ([string]([math]::round($totalSizer/[math]::pow(2,20),3))).replace(".",",") | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Size" -Value ([string]$null) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Count" -Value ([string]$null) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "TotalSize" -Value ([string]$null) | Out-Null
$TmpTable4+=$psDublicate
# Создание 2-й строки
$psDublicate=New-Object PSObject
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "fname" -Value ([string]"Из них занято дублями (Мб):") | Out-Null
#Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "MD5" -Value ([string]([math]::round($duplicateSizer/[math]::pow(2,20),3))) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "MD5" -Value ([string]("=СУММ(e{0}:e{1})" -f 7,(7+$fullsize-1))) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Size" -Value ([string]$null) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Count" -Value ([string]$null) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "TotalSize" -Value ([string]$null) | Out-Null
$TmpTable4+=$psDublicate

# Создание 3-й строки
$psDublicate=New-Object PSObject
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "fname" -Value ([string]"В процентном отношении:") | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "MD5" -Value ([string]"=100*b4/b3") | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Size" -Value ([string]$NULL) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Count" -Value ([string]$null) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "TotalSize" -Value ([string]$null) | Out-Null
$TmpTable4+=$psDublicate

# Создание 4-й строки
$psDublicate=New-Object PSObject
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "fname" -Value ([string]("".padleft(50,"-"))) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "MD5" -Value ([string]$null) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Size" -Value ([string]$null) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "Count" -Value ([string]$null) | Out-Null
Add-Member -InputObject $psDublicate -MemberType NoteProperty -Name "TotalSize" -Value ([string]$null) | Out-Null
$TmpTable4+=$psDublicate

# Добавление существующей таблицы с данными
$TmpTable4+=$f

# Вывод данных на экран
$TmpTable4 | Out-GridView

# Экспорт данных в Excel
$TmpTable4 | Export-Csv -Path $path -Encoding utf8

-----------------------------------------------------------------------------------------------------------------
